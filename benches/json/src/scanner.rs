// This file is @generated by Paguroidea.

#![allow(
    dead_code,
    non_camel_case_types,
    unused,
    unreachable_code,
    unused_assignments,
    unused_labels,
    unused_imports,
    clippy::single_match,
    clippy::never_loop,
    clippy::match_single_binding,
    clippy::identity_op,
)]
extern crate alloc;
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Tag {
    json,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParseTree<'a> {
    tag: Tag,
    src: &'a str,
    span: core::ops::Range<usize>,
    children: alloc::vec::Vec<Self>,
}
impl<'a> ParseTree<'a> {
    pub fn new(tag: Tag, src: &'a str) -> Self {
        Self {
            tag,
            src,
            span: 0..0,
            children: alloc::vec::Vec::new(),
        }
    }
    pub fn span(&self) -> core::ops::Range<usize> {
        self.span.clone()
    }
    pub fn len(&self) -> usize {
        self.span.len()
    }
    pub fn children(&self) -> &[Self] {
        &self.children
    }
    pub fn tag(&self) -> Tag {
        self.tag
    }
    pub fn as_slice(&self) -> &'a str {
        &self.src[self.span.clone()]
    }
    pub fn set_span(&mut self, span: core::ops::Range<usize>) {
        self.span = span;
    }
    pub fn add_child(&mut self, child: Self) {
        self.children.push(child);
    }
    pub fn next_level(mut self, tag: Tag, span: core::ops::Range<usize>) -> Self {
        self.set_span(span);
        let mut result = Self::new(tag, self.src);
        result.add_child(self);
        result
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Error {
    pub active_rule: Tag,
    pub expecting: &'static [&'static str],
    pub offset: usize,
}
impl core::fmt::Display for Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let expect = match self.expecting {
            [head] => head.to_string(),
            [init @ .., last] => format!("{} or {last}", init.join(", ")),
            _ => unsafe { std::hint::unreachable_unchecked() }
        };
        write!(
            f,
            "expecting {expect} for {:?} at offset {}",
            self.active_rule,
            self.offset,
        )
    }
}
impl std::error::Error for Error {}
fn parse_s55afa68415ac_15_0<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["COMMA"];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S0,
            S1,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b',') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_value_0(src, cursor, parent)?;
                                offset = cursor;
                                continue 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_attribute_0<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["STRING"];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S5,
            S7,
            S0,
            S8,
            S1,
            S2,
            S4,
            S6,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S5 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S6;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S7 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S8;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b'\"') => state = State::S2,
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S8 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S2;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S2 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_eq(u8x16::splat(b'\"'))
                                | data.simd_eq(u8x16::splat(b'\\'));
                            let idx_offset = mask.to_bitmask().trailing_zeros();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while !matches!(input.get(idx), Some(b'\"' | b'\\') | None) {
                            idx += 1;
                        }
                    }
                    match input.get(idx) {
                        Some(b'\"') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_attribute_3(src, cursor, parent)?;
                                cursor = parse_value_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'\\') => state = State::S4,
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S4 => {
                    match input.get(idx) {
                        Some(b'\"' | b'/' | b'\\' | b'b' | b'f' | b'n' | b'r' | b't') => {
                            state = State::S2;
                        }
                        Some(b'u') => state = State::S5,
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S6 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S7;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_s55afa684155a_19_0<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["COMMA"];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S0,
            S1,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b',') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_attribute_0(src, cursor, parent)?;
                                offset = cursor;
                                continue 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_value_0<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &[
        "FALSE",
        "LBRACKET",
        "LSQUARE",
        "NULL",
        "NUMBER",
        "STRING",
        "TRUE",
    ];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S0,
            S14,
            S2,
            S5,
            S7,
            S8,
            S10,
            S1,
            S4,
            S9,
            S6,
            S11,
            S13,
            S16,
            S15,
            S12,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b'\"') => state = State::S2,
                        Some(b'-') => state = State::S9,
                        Some(b'0') => state = State::S10,
                        Some(b'1'..=b'9') => state = State::S16,
                        Some(b'[') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_array_3(src, cursor, parent)?;
                                cursor = parse_array_8(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'f') => {
                            if input[idx + 1..].starts_with(b"alse") {
                                cursor = idx + 1 + 4usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'n') => {
                            if input[idx + 1..].starts_with(b"ull") {
                                cursor = idx + 1 + 3usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b't') => {
                            if input[idx + 1..].starts_with(b"rue") {
                                cursor = idx + 1 + 3usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'{') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_object_3(src, cursor, parent)?;
                                cursor = parse_object_8(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S14 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9') => state = State::S15,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S2 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_eq(u8x16::splat(b'\"'))
                                | data.simd_eq(u8x16::splat(b'\\'));
                            let idx_offset = mask.to_bitmask().trailing_zeros();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while !matches!(input.get(idx), Some(b'\"' | b'\\') | None) {
                            idx += 1;
                        }
                    }
                    match input.get(idx) {
                        Some(b'\"') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'\\') => state = State::S4,
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S5 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S6;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S7 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S8;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S8 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S2;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S10 => {
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'.') => state = State::S11,
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S4 => {
                    match input.get(idx) {
                        Some(b'\"' | b'/' | b'\\' | b'b' | b'f' | b'n' | b'r' | b't') => {
                            state = State::S2;
                        }
                        Some(b'u') => state = State::S5,
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S9 => {
                    match input.get(idx) {
                        Some(b'0') => state = State::S10,
                        Some(b'1'..=b'9') => state = State::S16,
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S6 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S7;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S11 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9') => state = State::S12,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S13 => {
                    match input.get(idx) {
                        Some(b'+' | b'-') => state = State::S14,
                        Some(b'0'..=b'9') => state = State::S15,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S16 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'.') => state = State::S11,
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S15 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S12 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            break 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_object_3<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["STRING"];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S4,
            S5,
            S0,
            S8,
            S1,
            S2,
            S7,
            S6,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S4 => {
                    match input.get(idx) {
                        Some(b'\"' | b'/' | b'\\' | b'b' | b'f' | b'n' | b'r' | b't') => {
                            state = State::S2;
                        }
                        Some(b'u') => state = State::S5,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S5 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S6;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b'\"') => state = State::S2,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S8 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S2;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S2 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_eq(u8x16::splat(b'\"'))
                                | data.simd_eq(u8x16::splat(b'\\'));
                            let idx_offset = mask.to_bitmask().trailing_zeros();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while !matches!(input.get(idx), Some(b'\"' | b'\\') | None) {
                            idx += 1;
                        }
                    }
                    match input.get(idx) {
                        Some(b'\"') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_attribute_3(src, cursor, parent)?;
                                cursor = parse_value_0(src, cursor, parent)?;
                                cursor = parse_s55afa684155a_19_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        Some(b'\\') => state = State::S4,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S7 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S8;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S6 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S7;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_array_8<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["RSQUARE"];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S0,
            S1,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b']') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_json_0(src: &str, mut offset: usize) -> Result<ParseTree, Error> {
    const EXPECTING: &[&str] = &[
        "FALSE",
        "LBRACKET",
        "LSQUARE",
        "NULL",
        "NUMBER",
        "STRING",
        "TRUE",
    ];
    let mut tree = ParseTree::new(Tag::json, src);
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S9,
            S8,
            S1,
            S0,
            S14,
            S15,
            S11,
            S16,
            S5,
            S4,
            S2,
            S6,
            S10,
            S12,
            S7,
            S13,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S9 => {
                    match input.get(idx) {
                        Some(b'0') => state = State::S10,
                        Some(b'1'..=b'9') => state = State::S16,
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S8 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S2;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b'\"') => state = State::S2,
                        Some(b'-') => state = State::S9,
                        Some(b'0') => state = State::S10,
                        Some(b'1'..=b'9') => state = State::S16,
                        Some(b'[') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_array_3(src, cursor, &mut tree)?;
                                cursor = parse_array_8(src, cursor, &mut tree)?;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: tree.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'f') => {
                            if input[idx + 1..].starts_with(b"alse") {
                                cursor = idx + 1 + 4usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: tree.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'n') => {
                            if input[idx + 1..].starts_with(b"ull") {
                                cursor = idx + 1 + 3usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: tree.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b't') => {
                            if input[idx + 1..].starts_with(b"rue") {
                                cursor = idx + 1 + 3usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: tree.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'{') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_object_3(src, cursor, &mut tree)?;
                                cursor = parse_object_8(src, cursor, &mut tree)?;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: tree.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S14 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9') => state = State::S15,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S15 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S11 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9') => state = State::S12,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S16 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'.') => state = State::S11,
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S5 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S6;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S4 => {
                    match input.get(idx) {
                        Some(b'\"' | b'/' | b'\\' | b'b' | b'f' | b'n' | b'r' | b't') => {
                            state = State::S2;
                        }
                        Some(b'u') => state = State::S5,
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S2 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_eq(u8x16::splat(b'\"'))
                                | data.simd_eq(u8x16::splat(b'\\'));
                            let idx_offset = mask.to_bitmask().trailing_zeros();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while !matches!(input.get(idx), Some(b'\"' | b'\\') | None) {
                            idx += 1;
                        }
                    }
                    match input.get(idx) {
                        Some(b'\"') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: tree.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        Some(b'\\') => state = State::S4,
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S6 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S7;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S10 => {
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'.') => state = State::S11,
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S12 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S7 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S8;
                        }
                        _ => {
                            return Err(Error {
                                active_rule: tree.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S13 => {
                    match input.get(idx) {
                        Some(b'+' | b'-') => state = State::S14,
                        Some(b'0'..=b'9') => state = State::S15,
                        _ => {
                            break 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    tree.set_span(offset..cursor);
    Ok(tree)
}
fn parse_attribute_3<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["COLON"];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S0,
            S1,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b':') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_object_8<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["RBRACKET"];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S1,
            S0,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b'}') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                break 'parser;
                            } else {
                                return Err(Error {
                                    active_rule: parent.tag,
                                    expecting: EXPECTING,
                                    offset,
                                });
                            }
                        }
                        _ => {
                            return Err(Error {
                                active_rule: parent.tag,
                                expecting: EXPECTING,
                                offset,
                            });
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
fn parse_array_3<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParseTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &[
        "FALSE",
        "LBRACKET",
        "LSQUARE",
        "NULL",
        "NUMBER",
        "STRING",
        "TRUE",
    ];
    let mut cursor;
    'parser: loop {
        cursor = offset;
        let input = src.as_bytes();
        enum State {
            S7,
            S4,
            S5,
            S6,
            S16,
            S10,
            S12,
            S13,
            S14,
            S15,
            S9,
            S0,
            S2,
            S8,
            S1,
            S11,
        }
        let mut idx = offset;
        let mut state = State::S0;
        'lexer: loop {
            match state {
                State::S7 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S8;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S4 => {
                    match input.get(idx) {
                        Some(b'\"' | b'/' | b'\\' | b'b' | b'f' | b'n' | b'r' | b't') => {
                            state = State::S2;
                        }
                        Some(b'u') => state = State::S5,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S5 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S6;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S6 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S7;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S16 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'.') => state = State::S11,
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                            break 'parser;
                        }
                    }
                }
                State::S10 => {
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'.') => state = State::S11,
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                            break 'parser;
                        }
                    }
                }
                State::S12 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        Some(b'E' | b'e') => state = State::S13,
                        _ => {
                            cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                            break 'parser;
                        }
                    }
                }
                State::S13 => {
                    match input.get(idx) {
                        Some(b'+' | b'-') => state = State::S14,
                        Some(b'0'..=b'9') => state = State::S15,
                        _ => {
                            cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                            break 'parser;
                        }
                    }
                }
                State::S14 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9') => state = State::S15,
                        _ => {
                            cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                            break 'parser;
                        }
                    }
                }
                State::S15 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'0'))
                                & data.simd_le(u8x16::splat(b'9'));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(input.get(idx), Some(b'0'..=b'9')) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                            break 'parser;
                        }
                    }
                }
                State::S9 => {
                    match input.get(idx) {
                        Some(b'0') => state = State::S10,
                        Some(b'1'..=b'9') => state = State::S16,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => state = State::S1,
                        Some(b'\"') => state = State::S2,
                        Some(b'-') => state = State::S9,
                        Some(b'0') => state = State::S10,
                        Some(b'1'..=b'9') => state = State::S16,
                        Some(b'[') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_array_3(src, cursor, parent)?;
                                cursor = parse_array_8(src, cursor, parent)?;
                                cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        Some(b'f') => {
                            if input[idx + 1..].starts_with(b"alse") {
                                cursor = idx + 1 + 4usize;
                                cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        Some(b'n') => {
                            if input[idx + 1..].starts_with(b"ull") {
                                cursor = idx + 1 + 3usize;
                                cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        Some(b't') => {
                            if input[idx + 1..].starts_with(b"rue") {
                                cursor = idx + 1 + 3usize;
                                cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        Some(b'{') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_object_3(src, cursor, parent)?;
                                cursor = parse_object_8(src, cursor, parent)?;
                                cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S2 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_eq(u8x16::splat(b'\"'))
                                | data.simd_eq(u8x16::splat(b'\\'));
                            let idx_offset = mask.to_bitmask().trailing_zeros();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while !matches!(input.get(idx), Some(b'\"' | b'\\') | None) {
                            idx += 1;
                        }
                    }
                    match input.get(idx) {
                        Some(b'\"') => {
                            if input[idx + 1..].starts_with(b"") {
                                cursor = idx + 1 + 0usize;
                                cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                                break 'parser;
                            } else {
                                break 'parser;
                            }
                        }
                        Some(b'\\') => state = State::S4,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S8 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f') => {
                            state = State::S2;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S1 => {
                    'lookahead: {
                        unsafe { ::pag_util::assume(idx <= input.len()) };
                        for chunk in input[idx..].chunks_exact(16) {
                            use core::simd::*;
                            let data = u8x16::from_slice(chunk);
                            let mask = data.simd_ge(u8x16::splat(b'\t'))
                                & data.simd_le(u8x16::splat(b'\n'))
                                | data.simd_eq(u8x16::splat(b'\r'))
                                | data.simd_eq(u8x16::splat(b' '));
                            let idx_offset = mask.to_bitmask().trailing_ones();
                            idx += idx_offset as usize;
                            if idx_offset != 16 {
                                break 'lookahead;
                            }
                        }
                        while matches!(
                            input.get(idx),
                            Some(b'\t'..=b'\n' | b'\r' | b' ')
                        ) {
                            idx += 1;
                        }
                    }
                    cursor = idx;
                    match input.get(idx) {
                        _ => {
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S11 => {
                    match input.get(idx) {
                        Some(b'0'..=b'9') => state = State::S12,
                        _ => {
                            cursor = parse_s55afa68415ac_15_0(src, cursor, parent)?;
                            break 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
pub fn parse(input: &str) -> Result<ParseTree, Error> {
    parse_json_0(input, 0)
}
