// This file is @generated by Paguroidea.

#![allow(
    non_snake_case,
    dead_code,
    non_camel_case_types,
    unused_variables,
    unused_mut,
    unreachable_patterns,
    unreachable_code,
    unused_assignments,
    unused_parens,
    clippy::identity_op,
    clippy::single_match,
    clippy::never_loop,
    clippy::match_single_binding,
    clippy::double_parens,
)]
extern crate alloc;
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Tag {
    string,
    tokens,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParserTree<'a> {
    tag: Tag,
    src: &'a str,
    span: core::ops::Range<usize>,
    children: alloc::vec::Vec<Self>,
}
impl<'a> ParserTree<'a> {
    pub fn new(tag: Tag, src: &'a str) -> Self {
        Self {
            tag,
            src,
            span: 0..0,
            children: alloc::vec::Vec::new(),
        }
    }
    pub fn len(&self) -> usize {
        self.span.len()
    }
    pub fn children(&self) -> &[Self] {
        &self.children
    }
    pub fn tag(&self) -> &Tag {
        &self.tag
    }
    pub fn as_slice(&self) -> &'a str {
        &self.src[self.span.clone()]
    }
    pub fn set_span(&mut self, span: core::ops::Range<usize>) {
        self.span = span;
    }
    pub fn add_child(&mut self, child: Self) {
        self.children.push(child);
    }
    pub fn next_level(mut self, tag: Tag, span: core::ops::Range<usize>) -> Self {
        self.set_span(span);
        let mut result = Self::new(tag, self.src);
        result.add_child(self);
        result
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Error {
    pub active_rule: Tag,
    pub expecting: &'static [&'static str],
    pub offset: usize,
}
impl core::fmt::Display for Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let expect = match self.expecting {
            [head] => head.to_string(),
            [init @ .., last] => format!("{} or {last}", init.join(", ")),
            _ => unsafe { std::intrinsics::unreachable() }
        };
        write!(
            f, "expecting {expect} for {:?} at offset {}", self.active_rule, self.offset
        )
    }
}
impl std::error::Error for Error {}
fn parse_tokens(src: &str, mut offset: usize) -> Result<ParserTree, Error> {
    const EXPECTING: &[&str] = &["STRING"];
    let mut tree = ParserTree::new(Tag::tokens, src);
    let mut cursor = offset;
    'parser: loop {
        let input = src.as_bytes();
        enum State {
            S2,
            S0,
            S3,
            S5,
        }
        let mut idx = offset;
        let mut state = State::S0;
        loop {
            match state {
                State::S2 => {
                    match input.get(idx) {
                        Some(b'\x00'..=b'!' | b'#'..=b'\xff') => state = State::S3,
                        Some(b'\"') => state = State::S5,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => {
                            idx += 1;
                            {
                                offset = idx;
                                continue 'parser;
                            }
                        }
                        Some(b'\"') => state = State::S2,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S3 => {
                    for i in input[idx..].array_chunks::<16>() {
                        use core::simd::*;
                        let data = u8x16::from_slice(i);
                        let idx_offset = {
                            let mask: u128 = unsafe {
                                core::mem::transmute(
                                    (data.simd_ge(u8x16::splat(b'\x00'))
                                        & data.simd_le(u8x16::splat(b'!')))
                                        | (data.simd_ge(u8x16::splat(b'#'))
                                            & data.simd_le(u8x16::splat(b'\xff'))),
                                )
                            };
                            mask.trailing_ones() / 8
                        };
                        idx += idx_offset as usize;
                        if core::intrinsics::unlikely(idx_offset != 16) {
                            break;
                        }
                    }
                    match input.get(idx) {
                        Some(b'\x00'..=b'!' | b'#'..=b'\xff') => state = State::S3,
                        Some(b'\"') => {
                            idx += 1;
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::string, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S600002BDC091_8(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S5 => {
                    match input.get(idx) {
                        Some(b'\"') => {
                            idx += 1;
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::string, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S600002BDC091_8(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::string, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S600002BDC091_8(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    tree.set_span(offset..cursor);
    Ok(tree)
}
fn parse_S600002BDC091_8<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParserTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &["STRING"];
    let mut cursor = offset;
    'parser: loop {
        let input = src.as_bytes();
        enum State {
            S2,
            S0,
            S3,
            S5,
        }
        let mut idx = offset;
        let mut state = State::S0;
        loop {
            match state {
                State::S2 => {
                    match input.get(idx) {
                        Some(b'\x00'..=b'!' | b'#'..=b'\xff') => state = State::S3,
                        Some(b'\"') => state = State::S5,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => {
                            idx += 1;
                            {
                                offset = idx;
                                continue 'parser;
                            }
                        }
                        Some(b'\"') => state = State::S2,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S3 => {
                    for i in input[idx..].array_chunks::<16>() {
                        use core::simd::*;
                        let data = u8x16::from_slice(i);
                        let idx_offset = {
                            let mask: u128 = unsafe {
                                core::mem::transmute(
                                    (data.simd_ge(u8x16::splat(b'\x00'))
                                        & data.simd_le(u8x16::splat(b'!')))
                                        | (data.simd_ge(u8x16::splat(b'#'))
                                            & data.simd_le(u8x16::splat(b'\xff'))),
                                )
                            };
                            mask.trailing_ones() / 8
                        };
                        idx += idx_offset as usize;
                        if core::intrinsics::unlikely(idx_offset != 16) {
                            break;
                        }
                    }
                    match input.get(idx) {
                        Some(b'\x00'..=b'!' | b'#'..=b'\xff') => state = State::S3,
                        Some(b'\"') => {
                            idx += 1;
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::string, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S5 => {
                    match input.get(idx) {
                        Some(b'\"') => {
                            idx += 1;
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::string, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::string, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
pub fn parse(input: &str) -> Result<ParserTree, Error> {
    parse_tokens(input, 0)
}
