// This file is @generated by Paguroidea.

#![allow(
    non_snake_case,
    dead_code,
    non_camel_case_types,
    unused_variables,
    unused_mut,
    unreachable_patterns,
    unreachable_code,
    unused_assignments,
    unused_parens,
    clippy::identity_op,
    clippy::single_match,
    clippy::never_loop,
    clippy::match_single_binding,
    clippy::double_parens,
)]
extern crate alloc;
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Tag {
    abcdef,
    abcd,
    abcdefghijklmnop,
    abcdefghijkl,
    abc,
    abcdefghijklmnopqr,
    abcdefghijklmnopqrs,
    ab,
    abcdefghijklmnopqrst,
    abcdefghijklmnopqrstu,
    abcdefghijklmnopqrstuvw,
    abcdefghijklmnopqrstuvwxy,
    abcdefghijklm,
    abcdefgh,
    abcdefg,
    abcde,
    abcdefghijklmnopqrstuvwxyz,
    a,
    abcdefghijk,
    abcdefghijklmnopqrstuvwx,
    abcdefghijklmno,
    abcdefghijklmnopq,
    abcdefghijklmnopqrstuv,
    abcdefghijklmn,
    tokens,
    abcdefghij,
    abcdefghi,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParserTree<'a> {
    tag: Tag,
    src: &'a str,
    span: core::ops::Range<usize>,
    children: alloc::vec::Vec<Self>,
}
impl<'a> ParserTree<'a> {
    pub fn new(tag: Tag, src: &'a str) -> Self {
        Self {
            tag,
            src,
            span: 0..0,
            children: alloc::vec::Vec::new(),
        }
    }
    pub fn len(&self) -> usize {
        self.span.len()
    }
    pub fn children(&self) -> &[Self] {
        &self.children
    }
    pub fn tag(&self) -> &Tag {
        &self.tag
    }
    pub fn as_slice(&self) -> &'a str {
        &self.src[self.span.clone()]
    }
    pub fn set_span(&mut self, span: core::ops::Range<usize>) {
        self.span = span;
    }
    pub fn add_child(&mut self, child: Self) {
        self.children.push(child);
    }
    pub fn next_level(mut self, tag: Tag, span: core::ops::Range<usize>) -> Self {
        self.set_span(span);
        let mut result = Self::new(tag, self.src);
        result.add_child(self);
        result
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Error {
    pub active_rule: Tag,
    pub expecting: &'static [&'static str],
    pub offset: usize,
}
impl core::fmt::Display for Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let expect = match self.expecting {
            [head] => head.to_string(),
            [init @ .., last] => format!("{} or {last}", init.join(", ")),
            _ => unsafe { std::intrinsics::unreachable() }
        };
        write!(
            f, "expecting {expect} for {:?} at offset {}", self.active_rule, self.offset
        )
    }
}
impl std::error::Error for Error {}
fn parse_tokens(src: &str, mut offset: usize) -> Result<ParserTree, Error> {
    const EXPECTING: &[&str] = &[
        "A",
        "AB",
        "ABC",
        "ABCD",
        "ABCDE",
        "ABCDEF",
        "ABCDEFG",
        "ABCDEFGH",
        "ABCDEFGHI",
        "ABCDEFGHIJ",
        "ABCDEFGHIJK",
        "ABCDEFGHIJKL",
        "ABCDEFGHIJKLM",
        "ABCDEFGHIJKLMN",
        "ABCDEFGHIJKLMNO",
        "ABCDEFGHIJKLMNOP",
        "ABCDEFGHIJKLMNOPQ",
        "ABCDEFGHIJKLMNOPQR",
        "ABCDEFGHIJKLMNOPQRS",
        "ABCDEFGHIJKLMNOPQRST",
        "ABCDEFGHIJKLMNOPQRSTU",
        "ABCDEFGHIJKLMNOPQRSTUV",
        "ABCDEFGHIJKLMNOPQRSTUVW",
        "ABCDEFGHIJKLMNOPQRSTUVWX",
        "ABCDEFGHIJKLMNOPQRSTUVWXY",
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    ];
    let mut tree = ParserTree::new(Tag::tokens, src);
    let mut cursor = offset;
    'parser: loop {
        let input = src.as_bytes();
        enum State {
            S5,
            S6,
            S18,
            S19,
            S21,
            S16,
            S24,
            S25,
            S23,
            S17,
            S22,
            S20,
            S2,
            S0,
            S3,
            S4,
            S8,
            S11,
            S13,
            S14,
            S15,
            S26,
            S10,
            S12,
            S9,
            S7,
        }
        let mut idx = offset;
        let mut state = State::S0;
        loop {
            match state {
                State::S5 => {
                    match input.get(idx) {
                        Some(b'E') => state = State::S6,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcd, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S6 => {
                    match input.get(idx) {
                        Some(b'F') => state = State::S7,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcde, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S18 => {
                    match input.get(idx) {
                        Some(b'R') => state = State::S19,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopq,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S19 => {
                    match input.get(idx) {
                        Some(b'S') => state = State::S20,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqr,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S21 => {
                    match input.get(idx) {
                        Some(b'U') => state = State::S22,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrst,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S16 => {
                    match input.get(idx) {
                        Some(b'P') => state = State::S17,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijklmno, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S24 => {
                    match input.get(idx) {
                        Some(b'X') => state = State::S25,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvw,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S25 => {
                    match input.get(idx) {
                        Some(b'Y') => state = State::S26,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvwx,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S23 => {
                    match input.get(idx) {
                        Some(b'W') => state = State::S24,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuv,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S17 => {
                    match input.get(idx) {
                        Some(b'Q') => state = State::S18,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnop,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S22 => {
                    match input.get(idx) {
                        Some(b'V') => state = State::S23,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstu,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S20 => {
                    match input.get(idx) {
                        Some(b'T') => state = State::S21,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrs,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S2 => {
                    match input.get(idx) {
                        Some(b'B') => state = State::S3,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::a, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => {
                            idx += 1;
                            {
                                offset = idx;
                                continue 'parser;
                            }
                        }
                        Some(b'A') => state = State::S2,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S3 => {
                    match input.get(idx) {
                        Some(b'C') => state = State::S4,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::ab, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S4 => {
                    match input.get(idx) {
                        Some(b'D') => state = State::S5,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abc, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S8 => {
                    match input.get(idx) {
                        Some(b'H') => state = State::S9,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefg, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S11 => {
                    match input.get(idx) {
                        Some(b'K') => state = State::S12,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghij, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S13 => {
                    match input.get(idx) {
                        Some(b'M') => state = State::S14,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijkl, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S14 => {
                    match input.get(idx) {
                        Some(b'N') => state = State::S15,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijklm, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S15 => {
                    match input.get(idx) {
                        Some(b'O') => state = State::S16,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijklmn, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S26 => {
                    match input.get(idx) {
                        Some(b'Z') => {
                            idx += 1;
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvwxyz,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvwxy,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S10 => {
                    match input.get(idx) {
                        Some(b'J') => state = State::S11,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghi, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S12 => {
                    match input.get(idx) {
                        Some(b'L') => state = State::S13,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijk, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S9 => {
                    match input.get(idx) {
                        Some(b'I') => state = State::S10,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefgh, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
                State::S7 => {
                    match input.get(idx) {
                        Some(b'G') => state = State::S8,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdef, src);
                            subtree.set_span(offset..cursor);
                            tree.add_child(subtree);
                            cursor = parse_S12D808FB6_378(src, cursor, &mut tree)?;
                            break 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    tree.set_span(offset..cursor);
    Ok(tree)
}
fn parse_S12D808FB6_378<'a>(
    src: &'a str,
    mut offset: usize,
    parent: &mut ParserTree<'a>,
) -> Result<usize, Error> {
    const EXPECTING: &[&str] = &[
        "A",
        "AB",
        "ABC",
        "ABCD",
        "ABCDE",
        "ABCDEF",
        "ABCDEFG",
        "ABCDEFGH",
        "ABCDEFGHI",
        "ABCDEFGHIJ",
        "ABCDEFGHIJK",
        "ABCDEFGHIJKL",
        "ABCDEFGHIJKLM",
        "ABCDEFGHIJKLMN",
        "ABCDEFGHIJKLMNO",
        "ABCDEFGHIJKLMNOP",
        "ABCDEFGHIJKLMNOPQ",
        "ABCDEFGHIJKLMNOPQR",
        "ABCDEFGHIJKLMNOPQRS",
        "ABCDEFGHIJKLMNOPQRST",
        "ABCDEFGHIJKLMNOPQRSTU",
        "ABCDEFGHIJKLMNOPQRSTUV",
        "ABCDEFGHIJKLMNOPQRSTUVW",
        "ABCDEFGHIJKLMNOPQRSTUVWX",
        "ABCDEFGHIJKLMNOPQRSTUVWXY",
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    ];
    let mut cursor = offset;
    'parser: loop {
        let input = src.as_bytes();
        enum State {
            S23,
            S17,
            S21,
            S26,
            S22,
            S5,
            S6,
            S12,
            S25,
            S24,
            S13,
            S4,
            S2,
            S7,
            S3,
            S10,
            S14,
            S9,
            S15,
            S18,
            S19,
            S16,
            S0,
            S8,
            S11,
            S20,
        }
        let mut idx = offset;
        let mut state = State::S0;
        loop {
            match state {
                State::S23 => {
                    match input.get(idx) {
                        Some(b'W') => state = State::S24,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuv,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S17 => {
                    match input.get(idx) {
                        Some(b'Q') => state = State::S18,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnop,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S21 => {
                    match input.get(idx) {
                        Some(b'U') => state = State::S22,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrst,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S26 => {
                    match input.get(idx) {
                        Some(b'Z') => {
                            idx += 1;
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvwxyz,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvwxy,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S22 => {
                    match input.get(idx) {
                        Some(b'V') => state = State::S23,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstu,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S5 => {
                    match input.get(idx) {
                        Some(b'E') => state = State::S6,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcd, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S6 => {
                    match input.get(idx) {
                        Some(b'F') => state = State::S7,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcde, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S12 => {
                    match input.get(idx) {
                        Some(b'L') => state = State::S13,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijk, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S25 => {
                    match input.get(idx) {
                        Some(b'Y') => state = State::S26,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvwx,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S24 => {
                    match input.get(idx) {
                        Some(b'X') => state = State::S25,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrstuvw,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S13 => {
                    match input.get(idx) {
                        Some(b'M') => state = State::S14,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijkl, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S4 => {
                    match input.get(idx) {
                        Some(b'D') => state = State::S5,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abc, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S2 => {
                    match input.get(idx) {
                        Some(b'B') => state = State::S3,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::a, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S7 => {
                    match input.get(idx) {
                        Some(b'G') => state = State::S8,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdef, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S3 => {
                    match input.get(idx) {
                        Some(b'C') => state = State::S4,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::ab, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S10 => {
                    match input.get(idx) {
                        Some(b'J') => state = State::S11,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghi, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S14 => {
                    match input.get(idx) {
                        Some(b'N') => state = State::S15,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijklm, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S9 => {
                    match input.get(idx) {
                        Some(b'I') => state = State::S10,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefgh, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S15 => {
                    match input.get(idx) {
                        Some(b'O') => state = State::S16,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijklmn, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S18 => {
                    match input.get(idx) {
                        Some(b'R') => state = State::S19,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopq,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S19 => {
                    match input.get(idx) {
                        Some(b'S') => state = State::S20,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqr,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S16 => {
                    match input.get(idx) {
                        Some(b'P') => state = State::S17,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghijklmno, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S0 => {
                    match input.get(idx) {
                        Some(b'\t'..=b'\n' | b'\r' | b' ') => {
                            idx += 1;
                            {
                                offset = idx;
                                continue 'parser;
                            }
                        }
                        Some(b'A') => state = State::S2,
                        _ => {
                            break 'parser;
                        }
                    }
                }
                State::S8 => {
                    match input.get(idx) {
                        Some(b'H') => state = State::S9,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefg, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S11 => {
                    match input.get(idx) {
                        Some(b'K') => state = State::S12,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(Tag::abcdefghij, src);
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
                State::S20 => {
                    match input.get(idx) {
                        Some(b'T') => state = State::S21,
                        _ => {
                            cursor = idx;
                            let mut subtree = ParserTree::new(
                                Tag::abcdefghijklmnopqrs,
                                src,
                            );
                            subtree.set_span(offset..cursor);
                            parent.add_child(subtree);
                            offset = cursor;
                            continue 'parser;
                        }
                    }
                }
            }
            idx += 1;
        }
    }
    Ok(cursor)
}
pub fn parse(input: &str) -> Result<ParserTree, Error> {
    parse_tokens(input, 0)
}
